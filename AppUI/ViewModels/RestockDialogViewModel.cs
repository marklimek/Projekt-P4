using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using ProjektP4.AppLogic.Models;
using System;

namespace ProjektP4.AppUI.ViewModels
{
    public partial class RestockDialogViewModel : ViewModelBase
    {
        public Product ProductToRestock { get; }

        // Make it a regular property instead of using [ObservableProperty] if you want to explicitly call NotifyCanExecuteChanged
        // OR, if keeping [ObservableProperty], you'd handle the change in a partial method.
        // Let's use the partial method approach for [ObservableProperty]
        [ObservableProperty]
        private int _quantityToAdd; // Keep [ObservableProperty] for INPC

        public event Action<int>? CloseRequested;

        // Use the [RelayCommand] attribute to generate the command properties
        [RelayCommand(CanExecute = nameof(CanConfirmRestock))]
        private void ConfirmRestock()
        {
            CloseRequested?.Invoke(QuantityToAdd);
        }

        private bool CanConfirmRestock() => QuantityToAdd >= 1;

        [RelayCommand]
        private void CancelRestock()
        {
            CloseRequested?.Invoke(0);
        }

        public RestockDialogViewModel(Product product)
        {
            ProductToRestock = product ?? throw new ArgumentNullException(nameof(product));
            QuantityToAdd = 1; // Default value
            // Commands are now auto-generated, no manual assignment needed here
        }

        // This partial method is generated by [ObservableProperty] and is called after the property changes.
        // It's the perfect place to manually trigger CanExecuteChanged.
        partial void OnQuantityToAddChanged(int value)
        {
            // Now, ConfirmRestockCommand exists as a public property due to the source generator.
            // We can safely call its NotifyCanExecuteChanged method.
            ConfirmRestockCommand.NotifyCanExecuteChanged();
        }
    }
}